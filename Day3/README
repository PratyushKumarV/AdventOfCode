# Puzzle 1 : I create a function called findSum() to appropriately calculate the product terms whenever mul() is encountered. I make sure that the mul() string is correct using various conditions to validate the operation and also for finding the numbers and then I return the sum. Sum is updated each and every time a mul() is encountered

# Puzzle 2 : The same findSum() function from puzzle 1 is used. Then I make sure the mul() operations are performed only when they are present between a do() and and a don't(). I also take care of two special cases. Case 1: It is possible that i<(dont) and the next mul() operation is greater than dont. In that case I have a condition to appropriately break out of the loop. Case 2: It is possible for mul to not be found in which case i becomes -1. In this case I initailize a new variable called check which holds i+1 before the find operation is done so that it breaks out of the loop and i updates appropriately to the next do() operation.
